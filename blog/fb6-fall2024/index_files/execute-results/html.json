{
  "hash": "5d4bd41ae6a442634e2e0b5e9a7c0ce5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: [Hemani Alaparthi, Coltin Colucci, Gregory M. Kapfhammer]\ntitle: Fuzzing with Grammars\ndate: '2024-10-28'\ndate-format: long\ncategories: [post, software engineering, fuzzing book]\ndescription: <em>Can we harness the power of grammars to generate smarter fuzzed inputs<</em>\ntoc: true\npage-layout: full\n---\n\n\n\n\n## Overview\n\nThis article dives into the [Fuzzing with Grammars] chapter from The [Fuzzing Book]() which builds on previous discussions, specifically those on [Mutation-Based Fuzzing](). By defining the legal inputs to a program through grammar specifications, we can streamline and enhance test generation, especially for complex formats. This chapter highlights the importance of structured inputs, which play a critical role in more advanced forms of fuzzing, including configuration fuzzing, API fuzzing, and GUI fuzzing. Here, we explore both the benefits and applications of grammar-based fuzzing, demonstrating how it offers a systematic approach for generating effective test cases across a range of input types. We will be exploring these practices and examining their relevance to our team’s current situation with execexam, connecting them to the concepts discussed last week to highlight how grammar-based fuzzing provides a systematic and effective approach to comprehensive test case generation.\n\n## Summary\n\n\n## Simplifying Grammar-Based Fuzzing\n\nGrammar-based fuzzing generates complex inputs for testing applications by systematically expanding grammar rules. The simple_grammar_fuzzer function begins with a start symbol (e.g., `<start>`) and iteratively expands it according to predefined grammar rules to create various expressions.\n\nWhile effective, this approach is computationally expensive due to repetitive search and replace operations. Additionally, it may encounter expansion errors when it hits limits, such as reaching the maximum number of nonterminals.\n\n**Activity: Using `nonterminals(\"<digit><integer>\")`, what nonterminals are extracted?**\n\n<details> <summary>Click to Expand for the Answer</summary>\nThe output is `[\"<digit>\", \"<integer>\"]`, as these are the symbols enclosed in angle brackets.\n</details>\n\n## Simple Grammar Fuzzer\n\nLet's put the grammars to use! The `simple_grammar_fuzzer` is a basic tool that generates random expressions by starting with a placeholder `(<start>)` and expanding it using a set of grammar rules. It replaces nonterminal symbols like `<expr>` or `<term>` with random elements according to these rules until a complete expression is formed. To prevent endless expansion, the fuzzer limits the number of placeholders and retries, though it’s not perfect and sometimes encounters errors.\n\n::: {#3aa9ed6f .cell execution_count=1}\n````````` {.python .cell-code}\nimport random\nimport re\nfrom typing import Any, Callable, Dict, List, Set, Tuple\n\nGrammar = Dict[str, List[str]]\n\ndef nonterminals(expansion):\n    return re.compile(r'(<[^<> ]*>)').findall(expansion)\n\nclass ExpansionError(Exception):\n    pass\n\ndef simple_grammar_fuzzer(grammar: Grammar, \n                          start_symbol: str = \"<start>\",\n                          max_nonterminals: int = 10,\n                          max_expansion_trials: int = 100,\n                          log: bool = False) -> str:\n    \"\"\"Produce a string from `grammar`.\n       `start_symbol`: use a start symbol other than `<start>` (default).\n       `max_nonterminals`: the maximum number of nonterminals \n         still left for expansion\n       `max_expansion_trials`: maximum # of attempts to produce a string\n       `log`: print expansion progress if True\"\"\"\n\n    term = start_symbol\n    expansion_trials = 0\n\n    while len(nonterminals(term)) > 0:\n        symbol_to_expand = random.choice(nonterminals(term))\n        expansions = grammar[symbol_to_expand]\n        expansion = random.choice(expansions)\n        # In later chapters, we allow expansions to be tuples,\n        # with the expansion being the first element\n        if isinstance(expansion, tuple):\n            expansion = expansion[0]\n\n        new_term = term.replace(symbol_to_expand, expansion, 1)\n\n        if len(nonterminals(new_term)) < max_nonterminals:\n            term = new_term\n            if log:\n                print(\"%-40s\" % (symbol_to_expand + \" -> \" + expansion), term)\n            expansion_trials = 0\n        else:\n            expansion_trials += 1\n            if expansion_trials >= max_expansion_trials:\n                raise ExpansionError(\"Cannot expand \" + repr(term))\n\n    return term\n`````````\n:::\n\n\nNow, we can fuzz with a Grammar.\n\n::: {#59fe3cd6 .cell execution_count=2}\n``` {.python .cell-code}\nEXPR_GRAMMAR: Grammar = {\n    \"<start>\":\n        [\"<expr>\"],\n\n    \"<expr>\":\n        [\"<term> + <expr>\", \"<term> - <expr>\", \"<term>\"],\n\n    \"<term>\":\n        [\"<factor> * <term>\", \"<factor> / <term>\", \"<factor>\"],\n\n    \"<factor>\":\n        [\"+<factor>\",\n         \"-<factor>\",\n         \"(<expr>)\",\n         \"<integer>.<integer>\",\n         \"<integer>\"],\n\n    \"<integer>\":\n        [\"<digit><integer>\", \"<digit>\"],\n\n    \"<digit>\":\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n}\n```\n:::\n\n\n::: {#dd4eee1c .cell execution_count=3}\n``` {.python .cell-code}\nfor i in range(10):\n    print(simple_grammar_fuzzer(grammar=EXPR_GRAMMAR, max_nonterminals=5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(-7) / ((-1)) * 44 + 73 / 2.18 * (((5) + (-+(+(-++(6)))) * (+((((+(-++(-+++8)))) / +1)) * (--8) - -((---((-(++1))) * 50) + --1 * 29 - (-+(7) / 3 - (0 + 4 + +(++-(-+((+-4)) - -+-+--4) * +9) * 4) / -+(-(7) * +(+-47.48)))))) + +3)\n+3.98083\n((((+5))) * (2 - 957.877)) * ++1 * ++(+1 + --((9) / +(-++++((-+7 / +-0 / (--9 * 2 + 2.32 - 8 - (092.8)) - 41)) + +3) - -+3)) * 42\n9 + (((7) + 2)) / -(+-+-1.741) * (((-4 - +5 * +((((+5 / 0))) + (+-(-(+--+(4)) + 32)) + 0 - (00)) * -7)))\n-+0.7 - 4.0\n0.9 - (-+--((42) / (-(-6) / --8 - 1.36 / 4) + -+0)) * (3)\n-3.1 - 30 + 0 / ++-6.2\n+(++(-(+(6)))) / --(((++(+(-(((-9 * (-(+8) + +98))))) * 3)) / +1)) * -3 - -(++1 - +((-(-(-+46)) - (+58 / 483))))\n4 / -(7) + -(+((1)) - +-+(9) * -13.1 / (7 / ((+4.5 * +1) * (0 / 68.32 * 56.0 * -2 * 4.8 * +--+06.5)) / 58.92)) - 7.1\n((2 * +(+(1))) * +0 + -(((-+((+-(+-(2) - -(60) + 1.884))) + -0 + -(8) * -0))) - -2 + ++2)\n```\n:::\n:::\n\n\nWhile our fuzzer does the job in most cases, it has a number of drawbacks.\n\n**Activity: What drawbacks does `simple_grammar_fuzzer()` have?:**\n\n**A. It has a large number of string search and replace operations**\n\n**B. It may fail to produce a string (ExpansionError)**\n\n**C. It often picks some symbol to expand that does not even occur in the string**\n\n**D. All of the above**\n\n<details> <summary>Click to Expand for the Answer</summary>\nThe answer is D!\n</details>\n\n\n### Some Grammars\n\nHere's a grammar for `cgi_decode()` introduced in the [Coverage](https://www.fuzzingbook.org/html/Coverage.html) chapter.\n\n::: {#2d1a9bd0 .cell execution_count=4}\n``` {.python .cell-code}\nCGI_GRAMMAR: Grammar = {\n    \"<start>\":\n        [\"<string>\"],\n\n    \"<string>\":\n        [\"<letter>\", \"<letter><string>\"],\n\n    \"<letter>\":\n        [\"<plus>\", \"<percent>\", \"<other>\"],\n\n    \"<plus>\":\n        [\"+\"],\n\n    \"<percent>\":\n        [\"%<hexdigit><hexdigit>\"],\n\n    \"<hexdigit>\":\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n            \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n\n    \"<other>\":  # Actually, could be _all_ letters\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"a\", \"b\", \"c\", \"d\", \"e\", \"-\", \"_\"],\n}\n```\n:::\n\n\n::: {#8814740a .cell execution_count=5}\n``` {.python .cell-code}\nfor i in range(10):\n    print(simple_grammar_fuzzer(grammar=CGI_GRAMMAR, max_nonterminals=10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n%f5\n+\ne%8d4\n%9b2\n%0f\n++\n%d7\na-\n0\n3\n```\n:::\n:::\n\n\n## Grammar Toolbox\nIn your own grammar toolbox there are many different ways in which you could use grammars. It is important to note that grammars are not very effective in meeting complex constraints. The example of this that is given in the FB book is that it would be hard to express a port range that is supposed to be between 1024 and 2048. There are a few different reasons why this would be hard to express, one of them being that there is a limited range the grammar could not allow a number larger than 2048. This means that there would have to be specific rules in place to make sure that 2048 is valid and 2049 is invalid. This can become extremely complex to express very quickly when having to set these types of parameters. An example where grammars may be more practical would be\nusing grammars as mutation seeds. The reason that grammars may be useful to use as an input is that they almost always can produce valid inputs from a syntactical standpoint. This is useful because when inputs are syntactically valid they can reveal other areas in which inputs may fail.\n\n\nAnother thing worth mentioning is escapes. Escapes can be used for delimiting nonterminals in grammars. This can be useful whenever you want to manipulate the input or output to have a specific value.\n\n::: {#c56ccecc .cell execution_count=6}\n``` {.python .cell-code}\nsimple_nonterminal_grammar: Grammar = {\n   \"<start>\": [\"<nonterminal>\"],\n   \"<nonterminal>\": [\"<left-angle><identifier><right-angle>\"],\n   \"<left-angle>\": [\"<\"],\n   \"<right-angle>\": [\">\"],\n   \"<identifier>\": [\"id\"]  # for now\n}\n```\n:::\n\n\n(Note that this does not work with simple_grammar_fuzzer(), but rather with the GrammarFuzzer class we'll introduce in the next chapter.)\n\n\nThere are also shortcuts that can be implemented to manipulate how symbols can be used in recursion.\n\n\n`<symbol>?` indicates that `<symbol>` is optional meaning it can occur 0 or 1 times.\n\n\n`<symbol>+` indicates that `<symbol>` can occur 1 or more times repeatedly\n\n\n`<symbol>*` indicates that `<symbol>` is completely optional.\n\n\nYou can also use parentheses to apply the shortcut to multiple symbols.\n\n\n`(<symbol><char>)?` would indicate that both < symbol > and < char > can optionally occur 0 or 1 times.\n\n\n\n\n## Checking Grammars\nGrammars are introduced as strings making it somewhat easy for there to be errors. There is a solution to this. The helper function is_valid_grammar() can assist in making sure that your grammars are working correctly. This function iterates through a grammar to make sure that all symbols are defined and in use. It also identifies if all symbols are reachable from the start symbol. This helper function should be implemented whenever you are using grammars to assure that the inputs you are giving are what you expected them to be.\n\n## Key Takeaways\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}