---
author: [Pallas-Athena Cain, Coltin Colucci, Chezka Quinola, Gregory M. Kapfhammer]
title: 'Style Guides and Rules'
date: '2024-11-18'
date-format: long
categories: [post, professional development, software engineering]
description: <em> How can rules scale and sustain engineering teams?</em>
toc: true
page-layout: full
---

## Overview

## Summary

### Why Have Rules?

Rules help to encourage "good" behavior and discourage "bad". But what is good and bad behavior when software engineering? We define the values of our project and so that is up for us to decide. Some companies really value consistency while others prioritize runtime optimization. The rules are meant to reinforce the organizational values and not so much be a limiting factor but more be way to encourage thoughtfulness when developing.

**Discussion Question: What values do we want to have for our codebases?**

### Creating the Rules

When creating the rules it is important to question why you are making something a rule. Questions you can ask yourself when think of rules are:

- "What goal or goals are we trying to advance?"
- "Why does this belong in the style guide?" 
- "What value does this rule add to our style guide?"
- "Does the rule bring us closer to our goal or goals?"

These are productive questions because they require you to reflect on why a rule exists instead of mindlessly creating rules for the sake of having rules.

#### Guiding Principles

Google has the coal of making the codebase manageable while still allowing for producitivity. However there is an important trade-off of making rules. **The larger the body of rules the more choice is restricted**. So the large body of rules should always be aiming to lead us towards our goals instead just acting as a limiting factor. 

Given this there are some overarching principles to guide in rule development which are: 

- Rules should pull their weight
- Rules should be optimized for the reader
- Rules should be consistent 
- Rules should avoid error-prone and surprising constructs
- Rules should concede to practicalities when necessary 

##### Rules Must Pull their Weight

With more rules it becomes increasly harder to remember them all. It can also become more expensive and challenging to maintain the more rules you have. 

Choose to not include rules that are self-evident because they add to everyone's mental load without being worth it.

For example in the context of our work we will not release debugging `print` statements in our production code. This rule is likely understood by all of us already and is not worth adding into an official style guide for that reason. 

##### Optimize for the Reader

Another guiding principle is writing code for the reader rather than the author. This goes back to the principle **Code is written once but read many times.** 

Simple to read > Simple to write

Trade-off: More cost more for engineers but earier to read.

Ways to make code easier to read:
- Longer and more descriptive variable names
- Using more descriptive conditional structures, `if` statements
- Descriptive doc-strings
- Well written comments 

Types of comments:
- Documentation Comments that describe the design or intent of the code that follows
- Implementation Comments justify or highlight non-obvious choices, underscore important parts, or explain the tricky parts

#####  Be Consistent

Consistency in code bases and in work spaces makes it easier to jump from project to project. Think about the setup between `gatorgrade` and `execexam` both utilize `poetry` so you were familiar with aspects of the tool before jumping in. That is part of why it is so hard to update `gatorgrader`. It was written before a lot of the dependancies we use in our other code bases so it is harder to get a grip on what is happening. That is why it is a task to convert it to method that is more consistent with the rest of our code bases. 

Why consistancy is good:
- Engineers can focuus on what's getting done over how it is presented 
- Chunking of problems; solving in a similar way
- Enables scaling code wise; make the code work the same everywhere
- Enables scaling humanwise; mobility across projects
- Resilience to time 

Do not let preserving consistancy stop you from updating your code at scale. If things change the standard may change and past code may need updated such as with `gatorgrader`

Setting the Standard

##### Avoid Error-prone and Surpising Constructs

##### Concede to Practicalities 


**Discussion Question: Can you describe one of the guiding principles and why it is important?**

<details>
<summary>Click to Expand for the Answer</summary>
TODO: 
</details>

#### The Style Guide

### Changing the Rules

#### The Process

#### The Style Arbiters

#### Exceptions

### Guidance

### Applying the Rules

#### Error Checkers

#### Code Formatters

## Reflection

## Action Items


{{< include /_back-blog.qmd >}}
