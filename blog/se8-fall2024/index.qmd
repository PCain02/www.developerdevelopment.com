---
author: [Pallas-Athena Cain, Coltin Colucci, Chezka Quinola, Gregory M. Kapfhammer]
title: 'Style Guides and Rules'
date: '2024-11-18'
date-format: long
categories: [post, professional development, software engineering]
description: <em> How can rules scale and sustain engineering teams?</em>
toc: true
page-layout: full
---

## Overview

## Summary

### Why Have Rules?

Rules help to encourage "good" behavior and discourage "bad". But what is good and bad behavior when software engineering? We define the values of our project and so that is up for us to decide. Some companies really value consistency while others prioritize runtime optimization. The rules are meant to reinforce the organizational values and not so much be a limiting factor but more be way to encourage thoughtfulness when developing.

**Discussion Question: What values do we want to have for our codebases?**

### Creating the Rules

When creating the rules it is important to question why you are making something a rule. Questions you can ask yourself when think of rules are:

- "What goal or goals are we trying to advance?"
- "Why does this belong in the style guide?" 
- "What value does this rule add to our style guide?"
- "Does the rule bring us closer to our goal or goals?"

These are productive questions because they require you to reflect on why a rule exists instead of mindlessly creating rules for the sake of having rules.

#### Guiding Principles

Google has the coal of making the codebase manageable while still allowing for producitivity. However there is an important trade-off of making rules. **The larger the body of rules the more choice is restricted**. So the large body of rules should always be aiming to lead us towards our goals instead just acting as a limiting factor. 

Given this there are some overarching principles to guide in rule development which are: 

- Rules should pull their weight
- Rules should be optimized for the reader
- Rules should be consistent 
- Rules should avoid error-prone and surprising constructs
- Rules should concede to practicalities when necessary 

##### Rules Must Pull their Weight

With more rules it becomes increasly harder to remember them all. It can also become more expensive and challenging to maintain the more rules you have. 

Choose to not include rules that are self-evident because they add to everyone's mental load without being worth it.

For example in the context of our work we will not release debugging `print` statements in our production code. This rule is likely understood by all of us already and is not worth adding into an official style guide for that reason. 

##### Optimize for the Reader

Another guiding principle is writing code for the reader rather than the author. This goes back to the principle **Code is written once but read many times.** 

Simple to read > Simple to write

Trade-off: More cost more for engineers but earier to read.

Ways to make code easier to read:
- Longer and more descriptive variable names
- Using more descriptive conditional structures, `if` statements
- Descriptive doc-strings
- Well written comments 

Types of comments:
- Documentation Comments that describe the design or intent of the code that follows
- Implementation Comments justify or highlight non-obvious choices, underscore important parts, or explain the tricky parts

#####  Be Consistent

Consistency in code bases and in work spaces makes it easier to jump from project to project. Think about the setup between `gatorgrade` and `execexam` both utilize `poetry` so you were familiar with aspects of the tool before jumping in. That is part of why it is so hard to update `gatorgrader`. It was written before a lot of the dependancies we use in our other code bases so it is harder to get a grip on what is happening. That is why it is a task to convert it to method that is more consistent with the rest of our code bases. 

Why consistancy is good:
- Engineers can focuus on what's getting done over how it is presented 
- Chunking of problems; solving in a similar way
- Enables scaling code wise; make the code work the same everywhere
- Enables scaling humanwise; mobility across projects
- Resilience to time 

Do not let preserving consistancy stop you from updating your code at scale. If things change the standard may change and past code may need updated such as with `gatorgrader`

Being consistent starts locally but sometimes stardards of the external community should be taken into account. An example of this that you have used before is citiation standards or the `YAML` standards for `yaml` files. We also using linting to make sure our codes are up to an outside standard.

An example they use in the book is that Google used to only use 2 space indents for their Python code but the outside community used 4. Eventually they realized the Google standard did not fit commpared to the outside standard. The more your code interacts with the outside world the more staying consistent with outside standards matter.

##### Avoid Error-prone and Surpising Constructs

Even if current understand a confusing construct there is no guarrentee the future will. These non-obvious features can cause misue and introduce bugs. 

Google's Python style guide avoids using `power` features such as relection. `hasattr()` and `getattr()` for example give access to an object using strings.

Example:

File one:
```python
A_CONSTANT = [
'foo',
'bar',
'baz',
]
```

File two:
```python
values = []
for field in some_file.A_CONSTANT:
values.append(getattr(my_object, field))
```

Confusing code can also cause security flaws since this code is hard to test and can be hard to notice if messages are validated incorrectly.

Some cases `hasattr()` and `getattr()` are valid but in most cases they are confusing. The traceback feature we have for example is a case where we needed to use these Python features to grab the information on the source code and source files. 

There is higher value in code that is understandable and easier to maintain than code that jumps to get the job done quickly.

##### Concede to Practicalities 

**“A foolish consistency is the hobgoblin of little minds.”** - Raplh Waldo Emerson 

It is okay to have exceptions to the style guide. Do not ignore everything else just because you are in pursuit of simple and consistant code. When needed excpetions can be made for optimizations and practicalities that otherwise would conflict with the rules.

**Discussion Question: Can you describe one of the guiding principles and why it is important?**

#### The Style Guide

### Changing the Rules 
Style guides are not static. As with many things in software engineering style guides are an ever evolving thing. With this being said certain styles can become outdated based on new features. if a rule is causing engineers to invest an excess amount of effort that may indicate that a change is needed. When looking into changing the rules first thing that is important to evaluate is why the rule is in place to start. In doing this evalutation it is also important to have evidence to back keeping a rule or creating a change. It is also important to document this reasons for change. In the future it will allow active users to have a more educated opinion on whether or not the rule is still effective or needs to be changed. An example of this is google using CamelCase as opponse to snake_case naming style for method names. The reason for this is that most of Google's Python usage at the time was for C++ developers using Python as a scripting layer on top of a C++ codebase. because Google's C++ naming convention follows CamelCase style, it was important to keep that consistent. When doing this they found that there were other issues with CamelCase. CamelCase did not conform with the third-party Python libraries that were being used. This made maintaining CamelCase more complex than needed to be. Another downside that was discovered was that this nonconformist convention was surprising and somewhat weird for the community. Ultimately when weighing the pros and cons of CamelCase and snake_case Google decided to switch back to snake_case naming in python.

#### The Process

The process used at google for changing a style guide is a solution based one. this means that if an update is proposed it has to be a solution to an existing problem and not a hypothetical situation.

Why might this be an effective approach?

#### The Style Arbiters

#### Exceptions

### Guidance ME

### Applying the Rules

#### Error Checkers

#### Code Formatters

## Reflection

## Action Items


{{< include /_back-blog.qmd >}}
